---
title: 'Mixture of contaminated normal distributions with different variables inflation
  factor within classes '
author: "Jorge Sanchez"
date: "2024-02-01"
output:
  html_document:
    df_print: paged
  pdf_document: default
header-includes:
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhf{}
  - \rfoot{\thepage}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(mclust) # unmmap function
library(DIRECT) #
library(MLmetrics)
library(xtable)
library(kableExtra)
library(knitr)
library(dplyr)
library(insight)
library(caret)
source("CMNFunctionsV2.R")
source("DifIFunctions.R")



write_matex <- function(x) {
  begin <- "$$\\begin{bmatrix}"
  end <- "\\end{bmatrix}$$"
  X <-
    apply(x, 1, function(x) {
      paste(
        paste(x, collapse = "&"),
        "\\\\"
      )
    })
  writeLines(c(begin, X, end))
}

write_matex2 <- function(x) {
  begin <- "\\begin{bmatrix}"
  end <- "\\end{bmatrix}"
  X <-
    apply(x, 1, function(x) {
      paste(
        paste(x, collapse = "&"),
        "\\\\"
      )
    })
  paste(c(begin, X, end), collapse = "")
}


loglikCMN_DIF1<-function(X,labels, par)
{

  if(is.null(par$sigma)) stop("The variance covariance matrix of dimension pxp is required 
                              in the parameters")
  if(is.null(par$eta)) stop("The  matrix whose columns contains the inflation factor for classes of dimension pxG is required 
                              in the parameters")
  if(is.null(par$mu)) stop("The  matrix mu whose columns contains the mean for classes of dimension pxG is required 
                              in the parameters")
  
  if(!is.array(par$mu)) stop("Parameter mu should be an array or matrix")
  if(!is.array(par$sigma)) stop("Parameter mu should be an array or matrix")
  if(!is.array(par$eta)) stop("Parameter eta should be an array or matrix")
  
  
  if(!all(dim(par$mu) == c(p,G))  ) stop("The matrix mu should be of dimension pXG, where the i^{th} column contains the inflation factor for the i^{th} class")
  
  if(!all(dim(par$sigma ) == c(p,p,G))  ) stop(" The parameter sigma should be an array of dimension pxpxG")
  if(!all(dim(par$eta) == c(p,G)) ) stop("The matrix eta should be of dimension pXG, where the i^{th} column contains the inflation factor for the i^{th} class")
  if(length(par$alpha) != G ) stop("The vector alpha should be of the length of the number of groups G")
  
  if(is.null(par$v) ) stop("The matrix of dimension mx2 with probabilities whether 
                           the sample ith is contaminated or non-contaminated is 
                            missed in the parameters")
  sigma <- array(0.0,dim = c(p,p,G))
  sg1 <- array(0.0,dim = c(p,p,G))
  inv_sigma <- array(0.0, dim = c(p,p,G) )
  mu <- matrix(0.0, ncol = G, nrow = p)
  eta <- matrix(0.0, ncol = G, nrow = p)
  inv_eta <- matrix(0.0, ncol = G, nrow = p)
  alpha <- numeric(G)
  
  
  # labels: class labels
  if(!is.matrix(X)) X <- as.matrix(X)
  mu <- as.matrix(par$mu)
  p <- ncol(X)
  m <- nrow(X)
  v <- par$v
  
  G <- length(unique(labels))
  pig <- par$pig
  alpha <- par$alpha
  eta <- par$eta
  sigma <- par$sigma
  
  l <- unmap(labels)
  M <- matrix(0.0, nrow = m, ncol = G)
  term1 <- 0
  term2 <- 0
  term3 <- 0
  
  v0 <- matrix(runif(m*G), nrow = m, ncol = G, byrow = TRUE)
  exit <- 0
  loglik <- c(0.0,0.0,0.0)   
  


  for(i_g in 1:G)     sg1 [,,i_g] <-t(diag( sqrt(eta[,i_g]), p ) ) %*% sigma[,,g] %*% diag( sqrt(eta[,i_g]), p )

  for (g in 1:G)
  {
    for(i in 1:m)
    {
      term1 <- log(pig[g])
        term2 <- v[i,g] * (log(alpha[g]) + dmvnorm( t(X[i,]) ,  mu[,g] , sigma[,,g] ,log = TRUE ) )
        term3<-(1-v[i,g]) * (log(1-alpha[g]) + dmvnorm( t(X[i,]) ,mu[,g],sg1[,,g], log = TRUE) )

        M[i,g] <- l[i,g]*(term1 + term2 + term3)   

      
    }
  }
  
  
  
  loglik <- sum(M)
  
  return(loglik)
}


mCmm_DIF_Diag1 <- function(Xtrain,ltrain,par,eta_max = 100, alpha_ref = 0.5)
{
  Xtrain <- as.matrix(Xtrain)
  m <- nrow(Xtrain)
  p <- ncol(Xtrain)
  G <- length(unique(ltrain))
  l <- unmap(ltrain)
  
  if(!is.array(par$mu)) stop("Parameter mu should be an array or matrix")
  if(!is.array(par$sigma)) stop("Parameter mu should be an array or matrix")
  if(!is.array(par$eta)) stop("Parameter eta should be an array or matrix")
  
  
  if (is.null(par$v)) v <- as.matrix(rep(1,m)) else v <- par$v
  
  if(is.null(par$sigma)) stop("The variance covariance matrix of dimension pxp is required 
                              in the parameters")
  if(is.null(par$eta)) stop("The  matrix whose columns contains the inflation factor for classes of dimension pxG is required 
                              in the parameters")
  if(is.null(par$mu)) stop("The  matrix mu whose columns contains the mean for classes of dimension pxG is required 
                              in the parameters")

    if(!all(dim(par$mu) == c(p,G))  ) stop("The matrix mu should be of dimension pXG, where the i^{th} column contains the inflation factor for the i^{th} class")
#  if(length(dim(par$sigma)) == 3)   if(!all(dim(par$sigma ) == c(p,p,G))  ) stop(" The parameter sigma should be an array of dimension pxpxG")
  if(!all(dim(par$sigma ) == c(p,p,G))  ) stop(" The parameter sigma should be an array of dimension pxpxG")
  if(!all(dim(par$eta) == c(p,G)) ) stop("The matrix eta should be of dimension pXG, where the i^{th} column contains the inflation factor for the i^{th} class")
  if(length(par$alpha) != G ) stop("The vector alpha should be of the length of the number of groups G")
  
  sigma <- array(0.0,dim = c(p,p,G))
  sg <- matrix(0.0,nrow = p, ncol = p)
  inv_sg <- matrix(0.0,nrow = p, ncol = p)
  inv_sigma <- array(0.0, dim = c(p,p,G) )
  eta <- matrix(0.0, ncol = G, nrow = p)
  inv_eta <- matrix(0.0, ncol = G, nrow = p)
  mu <- matrix(0.0, ncol = G, nrow = p)
  alpha <- numeric(G)

  # Initialization mu, Sigma, inv_sigma, Eta, and inverse of Eta -------------------------------------------
  alpha <- par$alpha
       for(g in 1:G)
       {
         eta[,g] <-par$eta
         mu[,g] <- par$mu[,g]
         sigma[,,g] <- par$sigma[,,g]
         inv_sigma[,,g] <- solve(sigma[,,g])
         inv_eta[,g] <- 1/eta[,g]
       }
  
  

  
  # v initialization --------------------------------------------------------
  
  if(is.null(par$v))
  {
    v<- matrix(rep(1,m*G), ncol = G, nrow = nrow(Xtrain))
  }else  v <- par$v
  
  
  # Calculations ------------------------------------------------------------
  
  
  mg <-apply(unmap(ltrain),2,sum)
  pig <- mg/m
  sum_lig_vig <- numeric(G)
  sig <- vector("list",m)
  sum_sig <- vector("list",G)
  sum_sig_xi <- vector("list",G)
  term1 <- vector("list",m)
  term2 <- vector("list",m)
  sumTerms<- vector("list",m)
  sumSigma <-vector("list",G)
  est_sigma <- array(0.0,dim = c(p,p,G) )
  est_alpha <- numeric(length(par$alpha))
  est_mu <- matrix(0.0,nrow=p,ncol=G) 
  est_eta <- matrix(0.0,nrow=p,ncol=G)

  # CM-step1 ----------------------------------------------------------------
  

  # numerator for calculating alphag
#  if(is.matrix(v) & is.matrix(l))
#  {
    
    sum_lig_vig <- sapply(1:G, function(g) {sum(l[,g]*v[,g]) })
    est_alpha <- max(alpha_ref,sum_lig_vig/mg)
    
  
  for(g in 1:G)
  {
    
    for(i in 1:m)
    {

       sig[[i]] <- l[i,g] *(   v[i,g] * inv_sigma[,,g] + 
                                  (1-v[i,g]) * diag(sqrt(inv_eta[,g]),p) %*% inv_sigma[,,g] %*% diag(sqrt(inv_eta[,g]),p)  )  
#         term1[[i]] <-v[i,g]* ( (Xtrain[i,]-mu[,g]) %*% t(Xtrain[i,]-mu[,g]) )
#          term2[[i]] <- (1-v[i,g]) * (diag(sqrt(inv_eta[,g]),p) %*% (Xtrain[i,]-mu[,g]) %*% t(Xtrain[i,]-mu[,g]) %*% diag(sqrt(inv_eta[,g]),p))
          term1[[i]] <-  ( v[i,g] * diag(1,p) + (1-v[i,g]) * diag(sqrt(inv_eta[,g]),p)  %*% diag(sqrt(inv_eta[,g]),p)  )  
          term2[[i]] <- (Xtrain[i,]-mu[,g]) %*% t( Xtrain[i,]-mu[,g] )
            
        if(G == 1)  sumTerms[[i]] <- l[i] *(term1[[i]] + term2[[i]])  
        if(G > 1)   sumTerms[[i]] <- l[i,g] *(term1[[i]] + term2[[i]])  

      if(i==1) 
      {
        sum_sig[[g]] <- 0
        sum_sig_xi[[g]] <-0
        sumSigma[[g]] <-0
      }  
      sum_sig[[g]]  <- sum_sig[[g]] + sig[[i]]
      sum_sig_xi[[g]] <-sum_sig_xi[[g]] + sig[[i]] %*% Xtrain[i,]
      aux_sumTerms <- diag(unlist(sumTerms[[i]]))
      sumSigma[[g]] <- sumSigma[[g]] + diag(aux_sumTerms,p)
    }# end-for i
    
    
    est_mu[,g] <- t(sum_sig_xi[[g]]) %*% solve(sum_sig[[g]])
    if(G==1) est_sigma[,,g] <- sumSigma[[g]]/ (det(sumSigma[[g]]) )^(1/p)
    if(G>1) est_sigma[,,g] <- sumSigma[[g]]/ (det(sumSigma[[g]]) )^(1/p)
  
    }# end-for g          
  

#}
    
est_invSigma <- array(0.0,dim = c(p,p,G))

for( g in 1:G)
{
#  if(is.list(est_sigma))
#    est_invSigma[,,g] <- solve(est_sigma[[g]])
  if(is.array(est_sigma))
  {
    if(length(dim(est_sigma)) == 2 )
      est_invSigma[,,g] <- solve(est_sigma)
    if(length(dim(est_sigma)) == 3 )
      est_invSigma[,,g] <- solve(est_sigma[,,g])
    
  }
}

# CM-step2 ----------------------------------------------------------------
est_eta <- matrix(0.0, ncol = G, nrow = p,)

b1 <- matrix(0.0, nrow = p, ncol = G)
b2 <- matrix(0.0, nrow = p, ncol = G)
a <- numeric(G)
factor3 <- 0

for(g in 1:G) a[g] <- sum(l[,g]*(1-v[,g]))

for(g in 1:G)
{
    for(j in 1:p)
    {
        b1[j,g]<-sum( l[,g]*(1-v[,g])*(X[,j]-est_mu[j,g])^2 )
    }
    if(a[g]!=0)
    {
      for(j in 1:p) b2[j,g]  <- b1[j,g]*est_invSigma[j,j,g]     
      est_eta[j,g] <- (max(1, b2[j,g]) / a[g])
    } else est_eta[j,g] <- 1

}


#for(g in 1:G)
#  for(i in 1:m)
#  {
#    a[g] <- a[g] + l[i,g]*(1-v[i,g])
#  }



for(g in 1:G)  
{
  for(j in 1:p)
  {
    factor3<-0
    for(i in 1:m)
    {
      factor3 <- ( est_invSigma[j,j,g] ) * ( l[i,g]*(1-v[i,g])*(Xtrain[i,j]- est_mu[j,g])^2 )
      #              cat("\n ",factor3," \n")
      b[j,g] <- b[j,g] + factor3  
    }
    if(a[g]!=0)
    {
      est_eta[j,g] <- max(1,b[j,g]/a[g])
    } else est_eta[j,g] <- 1
  }  
}




output <- list(mu = est_mu, sigma = est_sigma,
               inv_Sigma = est_invSigma,
               alpha = est_alpha ,eta = est_eta, pig = pig, G = G)

  return(output)
  
}

emCmn_DIF_Diag1 <- function(X, labels,  initpar = NULL, Maxiterations= 10, threshold = 0.01)
{
  # for Diagonal matrices

#  if(is.null(initpar$sigma)) stop("The variance covariance matrix of dimension pxp is required 
#                              in the parameters")
#  if(is.null(initpar$eta)) stop("The  matrix whose columns contains the inflation factor for classes of dimension pxG is required 
#                              in the parameters")
#  if(is.null(initpar$mu)) stop("The  matrix mu whose columns contains the mean for classes of dimension pxG is required 
#                              in the parameters")

#  if(!is.array(initpar$mu)) stop("Parameter mu should be an array or matrix")
#  if(!is.array(initpar$sigma)) stop("Parameter mu should be an array or matrix")
#  if(!is.array(initpar$eta)) stop("Parameter eta should be an array or matrix")
  
    
#  if(!all(dim(initpar$mu) == c(p,G))  ) stop("The matrix mu should be of dimension pXG, where the i^{th} column contains the inflation factor for the i^{th} class")
  
#  if(!all(dim(initpar$sigma ) == c(p,p,G))  ) stop(" The parameter sigma should be an array of dimension pxpxG")
#  if(!all(dim(initpar$eta) == c(p,G)) ) stop("The matrix eta should be of dimension pXG, where the i^{th} column contains the inflation factor for the i^{th} class")
#  if(length(initpar$alpha) != G ) stop("The vector alpha should be of the length of the number of groups G")
 
  parl <- list()
  sigma <- array(0.0,dim = c(p,p,G))
  inv_sigma <- array(0.0, dim = c(p,p,G) )
  eta <- matrix(0.0, ncol = G, nrow = p)
  inv_eta <- matrix(0.0, ncol = G, nrow = p)
  mu <- matrix(0.0, ncol = G, nrow = p)
  alpha <- numeric(G)
  
    
  if(!is.matrix(X)) X <- as.matrix(X)

  p <- ncol(X)
  m <- nrow(X)
  G <- length(unique(labels))

  v0 <- matrix(runif(m*G), nrow = m, ncol = G, byrow = TRUE)
  exit <- 0
  loglik <- c(0.0,0.0,0.0)   
  
  #if(is.null(par$G))  G <- length(unique(labels)) else  G <- par$G
  
  alpha0 <- rep(0.9,G)
  eta0 <- matrix(0.0, nrow = p , ncol = G)
  pig <- numeric(G)
  mu <- matrix(0.0, nrow = p , ncol = G)
  sigma <- array(0.0, dim = c(p,p,G))
  
  l <- unmap(labels)
  mg <- apply(l,2,sum)
  pig0 <-mg/length(labels)
  
  if(is.null(initpar))
  {
    mu0 <-sapply(1:G,function(g){
      apply(X[which(labels==g),],2,mean)
    })
    sigma0 <- array(0.0, dim = c(p,p,G))
    for(g in 1:G)
    {
      sigma0[,,g] <- diag(apply(X[which(labels==g),],2,var ),p)
      eta0[,g] <- rep(10,p) 
    }
    
    par <- list(G = G, pig = pig0, mu = mu0,
                sigma = sigma0, alpha = alpha0,
                eta = eta0, z = l, v =  v0)
    
  }else par <- list(G = initpar$G, pig = initpar$pig,
                    mu = initpar$mu, sigma = initpar$sigma,
                    alpha = initpar$alpha, eta = initpar$eta,
                    z =l, v = initpar$v)
  
  loglik[1] <- loglikCMN_DIF1(X,labels,par)  
  loglik[1]
  
  estep0 <- eCmn_DIF(X,labels,par)
  par$v <- estep0$v
  iter <- 0
  llvalue <- 0
  a <- 0
  b <- 0
  
  parl[[1]] <- list(G = par$G, pig = par$pig, mu = par$mu, sigma = par$sigma,
                    alpha = par$alpha, eta = par$eta, v = par$v)
  
  while(exit == 0)
  {
    iter <- iter + 1  
    parl[[iter]] <- list(G = par$G, pig = par$pig, mu = par$mu, sigma = par$sigma,
                    alpha = par$alpha, eta = par$eta, v = par$v)

    cat("\n E-M Iteration: ",iter,"\n")
    mstep1 <- mCmm_DIF_Diag1(X,labels,par)
    llvalue <- loglikCMN_DIF1(X,labels,par)
    par$pig <- mstep1$pig
    par$mu <- mstep1$mu
    par$sigma <- mstep1$sigma
    par$alpha <- mstep1$alpha
    par$eta <- mstep1$eta
    
    
    if(iter >= Maxiterations) 
    { 
      exit = 1
    }else {
      loglik[3] = loglik[2]
      loglik[2] = loglik[1]
      loglik[1] = llvalue
      if(iter > 2)
      {
        if(abs(loglik[2]-loglik[3]) == 0) 
        {
          exit = 1
        }else{
          a = (loglik[1]-loglik[2])/(loglik[2]-loglik[3])
          b = loglik[2] + (1/(1-a)*(loglik[1]-loglik[2]))
          if(abs(b-loglik[1])< threshold) exit = 1
        }
      }
    }
    estep1 <- eCmn_DIF(X,labels,par)
    par$v <- estep1$v
    
    
  }
  
  output <- list(G = par$G, pig = par$pig, mu = par$mu,
                 sigma = par$sigma, alpha = par$alpha, 
                 eta = par$eta, z = par$z, v = par$v,
                 iterations = iter,
                 ll = llvalue, par_iteration = parl)
  return(output)
}


eCmn_DIF<-function(X,labels,par)
{
  # eCmn_difIF E-step for contaminated mixture model with 
  #            different variable inflation factors within groups
  # X : matrix with the training data
  # l:  group information of the observations in training set
  # par:      parameters of the mixture of contaminated normal distribution with
  #           different variables inflation factor within groups
  
  m <- nrow(X)
  p <- ncol(X)
  if(is.null(par$alpha)) stop("A vector with the same length of number of groups 
                               that contains the percentage of non-contaminated 
                               samples is required")
  alpha <- par$alpha
  mu <- par$mu
  G <- length(unique(labels))
  if(is.null(par$pig)) stop("A vector of the same length of the number of groups
                            inidicating the percentage of observations in each class is missed
                            in the parameters")
  pig <- par$pig
  v <- matrix(0.0, ncol = G, nrow = m)
  z <- matrix(0.0, ncol = G, nrow = m)
  lhat <- rep(0,m)
  vhat <- rep(0,m)
  fxig <- matrix(0.0, ncol = G, nrow = m)
  thetaig <- matrix(0.0, ncol = G, nrow = m)
  numz <- matrix(0.0, ncol = G, nrow = m) # numerator for calculating zhat
  numv <- matrix(0.0, ncol = G, nrow = m) # numerator for calculating vhat
  denz <- rep(0,m)                        # denominator for calculating z hat
  denv <- matrix(0.0, ncol = G, nrow = m) # denominator for calculating v hat
  
  # sigma <- par$sigma
  # eta <- par$eta #  eta contains a matrix of dimension p x G, where each column corresponds
  #  the elements of the diagonal corresponding to variable inflation factor  
  #  for the group g
  output <- list()
  
  if(p == 1)
  {
    if (G == 1)
    {
      if (is.vector(par$sigma) & length(par$sigma) == 1)
      {
        if(is.vector(par$eta) & length(par$eta) == 1 )
        {
          sigma <- par$sigma
          eta <- par$eta
          sigma1 <- eta * sigma
        }else stop("The dimension of eta does not match")
      }else stop("The dimension of sigma does not match with the number of Groups")
    } else if ( G > 1)
    {
      if(is.vector(par$sigma) & length(par$sigma) == 1)
      {
        if(is.vector(par$eta) & length(par$eta) == 1)
        {
          eta <- rep(par$eta,G)
          sigma <- rep(par$sigma,G)
          sigma1 <- eta * sigma
        }else if(is.vector(par$eta) & length(par$eta) == G)
        {
          eta <- par$eta
          sigma <- rep(par$sigma,G)
          sigma1 <- eta * sigma
        }
        
      } else if ( is.vector(par$sigma) & length(par$sigma) == G)
      {
        if(is.vector(par$eta) & length(par$eta) == 1)
        {
          eta <- rep(par$eta,G)
          sigma <- par$sigma
          sigma1 <- eta * sigma
        }else if(is.vector(par$eta) & length(par$eta) == G)
        {
          eta <- par$eta
          sigma <- par$sigma
          sigma1 <- eta * sigma
        }
      }
    }
  }
  
  if(p > 1)
  {
    if(is.list(par$sigma) & G == 1)
    {
      if(is.vector(par$eta) & length(par$eta) == 1)
      {
        eta <- par$eta
        sigma <- matrix(unlist(par$sigma),ncol=p,nrow =p, byrow = TRUE)
        sigma1 <- eta * sigma
      }else if(is.vector(par$eta) & length(par$eta) == p)
      {
        eta <- diag(sqrt( par$eta),p)
        sigma <- matrix(unlist(par$sigma),ncol=p,nrow =p, byrow = TRUE)
        sigma1 <- t(eta) %*% sigma %*% eta
      }else if(is.matrix(par$eta))
      {
        sigma <- matrix(unlist(par$sigma),ncol=p,nrow =p, byrow = TRUE)
        sigma1 <- t(eta) %*% sigma %*% eta
        
      }else if(is.array(par$eta))
      {
        eta <- matrix(unlist(par$eta), ncol =p,nrow = p,byrow = TRUE)
        sigma <- matrix(unlist(par$sigma),ncol=p,nrow =p, byrow = TRUE)
        sigma1 <- t(eta) %*% sigma %*% eta
      }
      
    }
    if (is.matrix(par$sigma) & G == 1 )
    {   
      if(is.vector(par$eta) & length(par$eta) == 1)
      {
        eta <- par$eta
        sigma <- par$sigma
        sigma1 <- eta * sigma
      }else if(is.vector(par$eta) & length(par$eta) == p)
      {
        eta <- diag(sqrt( par$eta),p)
        sigma <- par$sigma
        sigma1 <- t(eta) %*% sigma %*% eta
      }else if(is.matrix(par$eta))
      {
        if(ncol(par$eta)!= p | nrow(par$eta)!= p) stop("The dimensions of the matrix eta are not pxp")
        if(ncol(par$eta) == p & nrow(par$eta)== p)
        {
          eta <- par$eta
          sigma <- par$sigma
          sigma1 <- t(eta) %*% sigma %*% eta
          
        }
      }else if(is.array(par$eta))
      {
        eta <- par$eta[,,1]
        sigma <- par$sigma
        sigma1 <-t(eta) %*% sigma %*% eta
      }
    }else if(is.matrix(par$sigma) & G > 1)
    {
      if(is.vector(par$eta) & length(par$eta) == 1)
      {
        eta <- par$eta
        sigma <- par$sigma
        sigma1 <- eta * sigma
      }else if(is.vector(par$eta) & length(par$eta) == p)
      {
        eta <- diag(sqrt(par$eta),p)
        sigma <- par$sigma
        sigma1 <- t(eta) %*% sigma %*% eta
      }else if(is.matrix(par$eta) & nrow(par$eta)== p & ncol(par$eta) == G)
      {
        sigma <- par$sigma
        eta <- array(0.0, dim =c(p,p,G) )
        sigma1 <- array(0.0, dim = c(p,p,G))
        for (i_g in 1:G)
        {
          eta[,,i_g] <- diag(sqrt(par$eta[,i_g]),p)
          sigma1[,,i_g] <- t(eta) %*% sigma %*% eta
        }
      }
      
    }else if(is.array(par$sigma) & length(dim(par$sigma))==3 )
    {
      if(is.vector(par$eta) & length(par$eta) == 1)
      {
        eta <- par$eta
        sigma <- par$sigma
        sigma1 <- array(0.0, dim =c(p,p,G))
        for(i_g in 1:G) sigma1[,,i_g] <- eta * sigma[,,i_g]
      }else if(is.vector(par$eta) & length(par$eta) == p)
      {
        eta <- diag(sqrt(par$eta),p)
        sigma <- par$sigma
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G) sigma1[,,i_g] <- t(eta) %*% sigma[,,i_g] %*% eta
      }else if(is.vector(par$eta) & length(par$eta) == G)
      {
        sigma <- par$sigma
        eta <- par$eta
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G) 
        {
          sigma1[,,i_g] <- eta[i_g] * sigma[,,i_g]
        }
      }else if(is.matrix(par$eta) & nrow(par$eta)== p & ncol(par$eta) == G)
      {
        sigma <- par$sigma
        eta <- array(0.0, dim = c(p,p,G))
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G)
        {
          eta[,,i_g] <- diag(sqrt(par$eta[,i_g]),p)
          sigma1[,,i_g] <- t(eta[,,i_g]) %*% sigma[,,i_g] %*% eta[,,i_g]
        }
      }else if( is.array(par$eta) ) 
      {
        if( all( dim(par$eta) == c(p,p,G) ) == TRUE  ) 
        {
          sigma <- par$sigma
          eta <- par$eta
          sigma1 <- array(0.0, dim = c(p,p,G))
          
          for (i_g in 1:G) sigma1[,,i_g] <- t(eta[,,i_g]) %*% sigma[,,i_g] %*% eta[,,i_g]
        }
      }
    }else if(is.list(par$sigma) & length(par$sigma) == G & G == 1)
    {
      if(is.vector(par$eta) & length(par$eta) == 1)
      {
        eta <- par$eta
        sigma <- par$sigma
        sigma1 <- array(0.0, dim =c(p,p,G))
        for(i_g in 1:G) sigma1[,,i_g] <- eta * sigma[,,i_g]
      }else if(is.vector(par$eta) & length(par$eta) == p)
      {
        eta <- diag(sqrt(par$eta),p)
        sigma <- par$sigma
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G) sigma1[,,i_g] <- t(eta) %*% sigma[,,i_g] %*% eta
      }else if(is.vector(par$eta) & length(par$eta) == G)
      {
        sigma <- par$sigma
        eta <- par$eta
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G) 
        {
          sigma1[,,i_g] <- eta[i_g] * sigma[,,i_g]
        }
      }else if(is.matrix(par$eta) & nrow(par$eta)== p & ncol(par$eta) == G)
      {
        sigma <- par$sigma
        eta <- array(0.0, dim = c(p,p,G))
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G)
        {
          eta[,,i_g] <- diag(sqrt(par$eta[,i_g]),p)
          sigma1[,,i_g] <- t(eta[,,i_g]) %*% sigma[,,i_g] %*% eta[,,i_g]
        }
      }else if( is.array(par$eta) ) 
      {
        if( all( dim(par$eta) == c(p,p,G) ) == TRUE  ) 
        {
          sigma <- array(0.0,dim = c(p,p,G))
          sigma1 <- array(0.0,dim = c(p,p,G))
          eta <- par$eta
          for (i_g in 1:G) 
          {
            sigma[,,i_g] <- par$sigma[[i_g]]
            sigma1[,,i_g] <- t(eta[,,i_g]) %*% sigma[,,i_g] %*% eta[,,i_g]
          }  
        }
      }
    }else if(is.list(par$sigma) & length(par$sigma)==G & G > 1)
    {
      if(is.vector(par$eta) & length(par$eta) == 1)
      {
        eta <- par$eta
        sigma <- par$sigma
        sigma1 <- array(0.0, dim =c(p,p,G))
        for(i_g in 1:G) sigma1[,,i_g] <- eta * sigma[,,i_g]
      }else if(is.vector(par$eta) & length(par$eta) == p)
      {
        eta <- diag(sqrt(par$eta),p)
        sigma <- par$sigma
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G) sigma1[,,i_g] <- t(eta) %*% sigma[,,i_g] %*% eta
      }else if(is.vector(par$eta) & length(par$eta) == G)
      {
        sigma <- par$sigma
        eta <- par$eta
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G) 
        {
          sigma1[,,i_g] <- eta[i_g] * sigma[,,i_g]
        }
      }else if(is.matrix(par$eta) & nrow(par$eta)== p & ncol(par$eta) == G)
      {
        sigma <- par$sigma
        eta <- array(0.0, dim = c(p,p,G))
        sigma1 <- array(0.0, dim = c(p,p,G))
        for(i_g in 1:G)
        {
          eta[,,i_g] <- diag(sqrt(par$eta[,i_g]),p)
          sigma1[,,i_g] <- t(eta[,,i_g]) %*% sigma[,,i_g] %*% eta[,,i_g]
        }
      }else if( is.array(par$eta) ) 
      {
        if( all( dim(par$eta) == c(p,p,G) ) == TRUE  ) 
        {
          sigma <- array(0.0,dim = c(p,p,G))
          sigma1 <- array(0.0,dim = c(p,p,G))
          eta <- par$eta
          for (i_g in 1:G) 
          {
            sigma[,,i_g] <- par$sigma[[i_g]]
            sigma1[,,i_g] <- t(eta[,,i_g]) %*% sigma[,,i_g] %*% eta[,,i_g]
          }  
        }
      }
    }
  }
  # Continuing here    
  # Calculating z's and v's
  
  for(g in 1:G)
  {
    for(i in 1:m)
    {
      if(p == 1 )
      {
        if( G == 1 & is.vector(par$sigma) & length(par$sigma)==1 &
            is.vector(par$eta) & length(par$eta) == 1)
        {
          # thetaig : matrix containing the probability of i-th observation in group g 
          # is not contaminated
          thetaig[i,g] <- dnorm(X[i,],mu,sigma)
          # fxig: matrix containing the probability of contaminated normal distribution for
          # observation i in group g
          fxig[i,g] <- alpha[g]*thetaig[i,g] + (1-alpha[g])*dnorm(X[i,],mu,sigma1)
        }else if(G >1 & is.vector(par$sigma) )
        {
          thetaig[i,g] <- dnorm(X[i,],mu[,g],sigma[g])
          # fxig: matrix containing the probability of contaminated normal distribution for
          # observation i in group g
          fxig[i,g] <- alpha[g]*thetaig[i,g] + (1-alpha[g])*dnorm(X[i,],mu[,g],sigma1[g])
          
        }
      } # end-if p == 1
      
      if(p > 1)
      {
        if(G == 1 & is.matrix(par$sigma) )
        {
          thetaig[i,g] <- dMVNorm(X[i,],mu,sigma)
          # fxig: matrix containing the probability of contaminated normal distribution for
          # observation i in group g
          fxig[i,g] <- alpha[g]*thetaig[i,g] + (1-alpha[g])*dMVNorm(X[i,],mu,sigma1)
          
        }else if(G > 1 & is.matrix(par$sigma) & is.vector(par$eta) )
        {
          thetaig[i,g] <- dMVNorm(X[i,],mu[,g],sigma)
          # fxig: matrix containing the probability of contaminated normal distribution for
          # observation i in group g
          fxig[i,g] <- alpha[g]*thetaig[i,g] + (1-alpha[g])*dMVNorm(X[i,],mu[,g],sigma1)
          
        }else if(G>1 & is.matrix(par$sigma) & is.matrix(par$eta))
        {
          thetaig[i,g] <- dMVNorm(X[i,],mu[,g],sigma)
          # fxig: matrix containing the probability of contaminated normal distribution for
          # observation i in group g
          fxig[i,g] <- alpha[g]*thetaig[i,g] + (1-alpha[g])*dMVNorm(X[i,],mu[,g],sigma1[,,g])
          
        }else if(G>=1 & is.array(par$sigma)  )
        {
          thetaig[i,g] <- dMVNorm(X[i,],mu[,g],sigma[,,g])
          # fxig: matrix containing the probability of contaminated normal distribution for
          # observation i in group g
          fxig[i,g] <- alpha[g]*thetaig[i,g] + (1-alpha[g])*dMVNorm(X[i,],mu[,g],sigma1[,,g])
          
        }else if(G>=1 & is.list(par$sigma) )
        {
          thetaig[i,g] <- dMVNorm(X[i,],mu[,g],sigma[,,g])
          # fxig: matrix containing the probability of contaminated normal distribution for
          # observation i in group g
          fxig[i,g] <- alpha[g]*thetaig[i,g] + (1-alpha[g])*dMVNorm(X[i,],mu[,g],sigma1[,,g])
          
        }
      } # end-if p > 1
      
      
      
      # avoid division by zero
      numz[i,g] <- pig[g] * fxig[i,g]
      numv[i,g] <- alpha[g] * thetaig[i,g]
      denv[i,g] <- fxig[i,g]
      v[i,g] <- numv[i,g]/denv[i,g]
      
      
    }#End-for i
    
  }#End-for G
  
  # calculating zhat and lhat
  
  # calculating zhat and lhat
  denzi <- apply(numz,1,sum)
  for (i in 1:m)
  {
    z[i,] <- numz[i,]/denzi[i]
  }
  lhat<-apply(z,1,which.max)
  for (i in 1:m)
  {
    vhat[i] <- ifelse(v[i,labels[i]]>0.5,1,0)
  }
  
  output <- list(z = z, v = v, lhat = lhat, vhat = vhat )
  return(output)
  
  
}






# DatasetB
G_b <- 1
p_b <- 3 # 3 variables
nobs_b <- 3000
ptraining <- 0.5
percentage_trainning <-round(ptraining*100)
m <- nobs_b *ptraining
pig_b <- 1
mu_b <- matrix(c(0,0,0), nrow = p_b, ncol = G_b, byrow = TRUE)
sigma_b <- array(0,dim = c(p_b,p_b,G_b))
sigma_b[,,1] <- diag(c(1/2,1/4,1/2),p_b)
alpha_b <- 0.70
# for function Sim_DF
# ---------------------------------------------------------------------------------------------------
# eta is passed as a vector when there is one group where each element represent the variance inflation factor of a variable
# eta is passed as a matrix with each column correspond to the diagonal elements of the variance-covariance of a group

eta_b <- c(2,5,2)
# ---------------------------------------------------------------------------------------------------

DatasetB <- Sim_DIF(mu_b,sigma_b,pig_b,nobs_b,ptraining,alpha_b,eta_b)
#saveRDS(DatasetB,"DatasetB.RDS")
#DatasetB <- readRDS("DatasetB.RDS")


# Obtaining initial values for parameters
  mu_0 <- as.matrix(apply(DatasetB$Xtrain,2,mean))
  mu_0
  
  
  apply(DatasetB$Xtrain[DatasetB$vtrain==1,],2,var)
  apply(DatasetB$Xtrain[DatasetB$vtrain==0,],2,var)
  var(DatasetB$Xtrain)
      
  var_0 <- diag(apply(DatasetB$X,2,var),p_b)
  var_0 
  sigma_0 <- array(0.0, dim = c(p_b,p_b,G_b))
  sigma_0[,,1] <- array(as.vector(var_0), dim=c(p_b,p_b,G_b))
  
  alpha_0 <- 0.9
  
  eta_0 <- matrix(0.0, ncol = G_b, nrow = p_b)
  eta_0[,1] <- rep(1.10,p_b)
#  Running the M-step when the labels are the true and estimate the parameters



par_0 <- list(G_b = 1, pig = pig_b, mu = mu_0,
                 sigma = sigma_0,
                 alpha = alpha_0,
                 eta = eta_0)



par_0$v <-matrix(runif(nrow(DatasetB$Xtrain)*G_b), ncol = G_b, nrow = nrow(DatasetB$Xtrain), byrow = TRUE)

# for function Sim_DF
# ---------------------------------------------------------------------------------------------------
# eta is passed as a vector when there is one group where each element represent the variance inflation factor of a variable
# eta is passed as a matrix with each column correspond to the diagonal elements of the variance-covariance of a group

ms_BDifrealv <- mCmm_DIF_Diag1(Xtrain = DatasetB$Xtrain,ltrain = DatasetB$ltrain, par = par_0)




ms_BDifrealv$mu
ms_BDifrealv$sigma
ms_BDifrealv$alpha
ms_BDifrealv$eta


# round estimated parameters  
mu_BrealDifr <- round(ms_BDifrealv$mu,2)
sigma_BrealDifr<- round(ms_BDifrealv$sigma,2)
alpha_BrealDifr <- round(ms_BDifrealv$alpha,2)
eta_BrealDifr <- round(ms_BDifrealv$eta,2)

mu_BrealDifr
sigma_BrealDifr
alpha_BrealDifr
eta_BrealDifr

var_02 <- array(0.0, dim = c(p_b,p_b,G_b))
var_02 [,,1]<- matrix(var_0, nrow = p_b, ncol = p_b)
par_02 <- list(G_b = 1, pig = pig_b, mu = mu_0,
                 sigma = var_02,
                 alpha = alpha_0,
                 eta = matrix( c ( rep(1.10,p_b) ), nrow = p_b,ncol = G_b )  )

par_02$v <-matrix(runif(nrow(DatasetB$Xtrain)*G_b), ncol = G_b, nrow = nrow(DatasetB$Xtrain), byrow = TRUE)

ms_BDifrealv1 <- mCmm_DIF_Diag1(Xtrain = DatasetB$Xtrain,ltrain = DatasetB$ltrain, par = par_02)

es_BDifrealv1 <- eCmn_DIF(X = DatasetB$Xtrain,labels = DatasetB$ltrain, par = par_02)

 loglikCMN_DIF1(X = DatasetB$Xtrain,labels = DatasetB$ltrain,par = par_02)  

# fit the data with model allowing different variable inflation factor within group
# without passing initial parameters

# round estimated parameters  
mu_BrealDifr1 <- round(ms_BDifrealv1$mu,2)
sigma_BrealDifr1<- round(ms_BDifrealv1$sigma,2)
alpha_BrealDifr1 <- round(ms_BDifrealv1$alpha,2)
eta_BrealDifr1 <- round(ms_BDifrealv1$eta,2)

mu_BrealDifr1
sigma_BrealDifr1
alpha_BrealDifr1
eta_BrealDifr1

# fit_BDif <- emCmn_DIF_EII(X = DatasetB$Xtrain,labels = DatasetB$ltrain, Maxiterations = 1000)

# fit the data with model allowing different variable inflation factor within group
# passing the equal inflation factor as initial parameters

#fit_BEq <- ContaminatedMixt::CNmixt(X = DatasetB$Xtrain,G = G_b, contamination = TRUE, model = "VVV",
#                  initialization = "mixt", label = DatasetB$ltrain)

#par_01 <- list(G = G_b, pig = pig_b, mu = fit_BEq$models[[1]]$mu,
#             sigma = fit_BEq$models[[1]]$Sigma, alpha = fit_BEq$models[[1]]$alpha,
#             eta = fit_BEq$models[[1]]$eta, z = DatasetB$ltrain,
#             v = fit_BEq$models[[1]]$v)

#fit_BDif <- emCmn1_DIF_EII(X = DatasetB$Xtrain,labels = DatasetB$ltrain, par0,
#                           Maxiterations = 1000, threshold = 0.01)


var_02 <- array(0.0, dim = c(p_b,p_b,G_b))
var_02 [,,1]<- matrix(var_0, nrow = p_b, ncol = p_b)

par_02 <- list(G_b = 1, pig = pig_b, mu = mu_0,
                 sigma = var_02,
                 alpha = 0.97,
                 eta = matrix( c ( 1,2,1) , nrow = p_b,ncol = G_b )  )

par_02$v <-matrix(runif(nrow(DatasetB$Xtrain)*G_b), ncol = G_b, nrow = nrow(DatasetB$Xtrain), byrow = TRUE)


eta_01 <- array(0.0,dim =  c(p_b,p_b,G_b))
eta_01[,,1] <- diag(c(2,5,7),p_b) 
sigma_01 <-array(0.0,dim =  c(p_b,p_b,G_b))
sigma_01[,,1] <- diag(runif(3),3)

par_01 <- list(G = G_b, pig = pig_b, mu = mu_0,
             sigma = sigma_01, alpha = 0.99,
             eta = eta_01, z = DatasetB$ltrain,
             v = matrix( runif(G_b*nrow(DatasetB$Xtrain)) , ncol = G_b, nrow = nrow(DatasetB$Xtrain), byrow = TRUE) )

fit_BDif <- emCmn_DIF_Diag1(X = DatasetB$Xtrain,labels = DatasetB$ltrain, par_02,
                           Maxiterations = 1000, threshold = 0.01)


par_BDif <- NULL
par_BDif <- list(G = fit_BDif$G, pig = fit_BDif$pig, mu = fit_BDif$mu,
                 sigma = matrix(as.vector(fit_BDif$sigma),ncol=p_b,nrow=p_b,byrow = TRUE ),
                 alpha = fit_BDif$alpha,
                 eta = matrix(as.vector(fit_BDif$eta),ncol=p_b,nrow=p_b,byrow = TRUE ) )

predBDifTrainv <- fit_BDif$v

predBDifTestv <- eCmn_DIF(X = DatasetB$Xtest,labels = DatasetB$ltest, par = par_BDif)


pred_BDifTrainv <- ifelse(predBDifTrainv>0.5,1,0)
Factpred_BDifTrainv <- factor(pred_BDifTrainv, levels = c("0","1"),
                         labels=c("Cont","Non-cont"))
Fact_BTrainv <- factor(DatasetB$vtrain, levels = c("0","1"),
                     labels = c("Cont","Non-cont"))

CM_BDifTrainv <- ConfusionMatrix(Factpred_BDifTrainv,Fact_BTrainv)

CompBDifTrainv <- cbind(True = DatasetB$vtrain, Pred = pred_BDifTrainv)


pred_BDifTestv <- ifelse(predBDifTestv$vhat>0.5,1,0)
Factpred_BDifTestv <- factor(pred_BDifTestv, levels = c("0","1"),
                         labels=c("Cont","Non-cont"))
Fact_BTestv <- factor(DatasetB$vtest, levels = c("0","1"),
                     labels = c("Cont","Non-cont"))

CM_BDifTestv <- ConfusionMatrix(Factpred_BDifTestv,Fact_BTestv)

CompBDifTestv <- cbind(True = DatasetB$vtest, Pred = pred_BDifTestv)

# condition 1 True contaminated samples

condTrueBDif_0Trainv <- CompBDifTrainv[,1] == 0
condPredBDif_1Trainv <- CompBDifTrainv[,2] == 1
condPredBDif_0Trainv <- CompBDifTrainv[,2] == 0

condBDif_01Trainv <- condTrueBDif_0Trainv & condPredBDif_1Trainv
condBDif_00Trainv <- condTrueBDif_0Trainv & condPredBDif_0Trainv

indBDif_T0_P1_Trainv <- which(condBDif_01Trainv == TRUE)
indBDif_T0_P0_Trainv <- which(condBDif_00Trainv == TRUE)

CompBDifTrainv[indBDif_T0_P1_Trainv,]
cond1BDif_trainv <- paste0(DatasetB$vtrain,pred_BDifTrainv)


condTrueBDif_0Testv <- CompBDifTestv[,1] == 0
condPredBDif_1Testv <- CompBDifTestv[,2] == 1
condPredBDif_0Testv <- CompBDifTestv[,2] == 0

condBDif_01Testv <- condTrueBDif_0Testv & condPredBDif_1Testv
condBDif_00Testv <- condTrueBDif_0Testv & condPredBDif_0Testv

indBDif_T0_P1_Testv <- which(condBDif_01Testv == TRUE)
indBDif_T0_P0_Testv <- which(condBDif_00Testv == TRUE)
CompBDifTestv[indBDif_T0_P1_Testv,]
cond1BDif_testv <- paste0(DatasetB$vtest,pred_BDifTestv)
table(cond1BDif_testv)

# round estimated parameters  
mu_BDifr <- round(fit_BDif$mu,2)
sigma_BDif <- fit_BDif$sigma
sigma_BDifr<- round(matrix(as.vector(fit_BDif$sigma),ncol = p_b,nrow= p_b,byrow = TRUE ),2 )
alpha_BDifr <- round(fit_BDif$alpha,2)
eta_BDifr <- round(fit_BDif$eta,2)


pred_BDifTrainv

Accuracy_BDifTrain <- Accuracy(pred_BDifTrainv,DatasetB$vtrain)
Sensitivity_BDifTrain <- Sensitivity(DatasetB$vtrain, pred_BDifTrainv,positive = 0)
Specificity_BDifTrain <- Specificity(DatasetB$vtrain,pred_BDifTrainv,positive = 0) 
Recall_BDifTrain <- Recall(DatasetB$vtrain, pred_BDifTrainv,positive = 0) 
Precision_BDifTrain <- Precision(DatasetB$vtrain,pred_BDifTrainv,positive = 0) 
ConfusionMatrix_BDifTrain <- ConfusionMatrix(pred_BDifTrainv,DatasetB$vtrain)
ConfusionDF_BDifTrain <- ConfusionDF(pred_BDifTrainv,DatasetB$vtrain)
F1_Score_BDifTrain <- F1_Score(DatasetB$vtrain,pred_BDifTrainv,positive = 0)

pred_BDifTest <-predBDifTestv 

Accuracy_BDifTest <- Accuracy(pred_BDifTest$vhat,DatasetB$vtest)
Sensitivity_BDifTest <- Sensitivity(DatasetB$vtest, pred_BDifTest$vhat,positive = 0)
Specificity_BDifTest <- Specificity(DatasetB$vtest,pred_BDifTest$vhat,positive = 0) 
Recall_BDifTest <- Recall(DatasetB$vtest, pred_BDifTest$vhat,positive = 0) 
Precision_BDifTest <- Precision(DatasetB$vtest,pred_BDifTest$vhat,positive = 0) 
ConfusionMatrix_BDifTest <- ConfusionMatrix(pred_BDifTest$vhat,DatasetB$vtest)
ConfusionDF_BDifTest <- ConfusionDF(pred_BDifTest$vhat,DatasetB$vtest)
F1_Score_BDifTest <- F1_Score(DatasetB$vtest,pred_BDifTest$vhat,positive = 0)


CM_BDifTrainv
CM_BDifTestv





df_BDifTrain <-  data.frame(
  Metric = c("Accuracy","Precision","Recall","Sensitivity","Specificity",
             "F1 score"),
  Different_IF = c(round(Accuracy_BDifTrain,2),round(Precision_BDifTrain,2),
                   round(Recall_BDifTrain,2),round(Sensitivity_BDifTrain,2),
                   round(Specificity_BDifTrain,2),
            round(F1_Score_BDifTrain,2))
)



df_BDifTest <- data.frame(
  Metric = c("Accuracy","Precision","Recall","Sensitivity","Specificity",
             "F1 score"),
  Different_IF = c(round(Accuracy_BDifTest,2),round(Precision_BDifTest,2),
                   round(Recall_BDifTest,2),round(Sensitivity_BDifTest,2),
                   round(Specificity_BDifTest,2),
            round(F1_Score_BDifTest,2))
)


df_BDifTrain
df_BDifTest

table(DatasetB$vtrain)
table(DatasetB$vtest)

table(DatasetB$vtrain, pred_BDifTrainv)

table(DatasetB$vtest, pred_BDifTestv)

#View(df_BDifTrain)
#View(df_BDifTest)

```

## Introduction
 The traditional contaminated mixture model assumed that the contamination is the same for all variables within groups. The contaminated mixture model each group with a mixture of two normal distributions with two components. The first normal distribution models the non-contaminated samples while the second component models the contaminated samples. The contamination is control by two parameters which are the proportion of non-contaminated samples in each group $\alpha_{g}$ and the inflation factor $\eta_{g}$ that is the same for all variables within group.

$$
    f(\mathbf{x}|\vartheta) = \sum^{G}_{g=1} \pi_{g} \left[\alpha_{g} \mathcal{N}(x|\boldsymbol{\mu}_{g},\boldsymbol{\Sigma}_{g})  + (1-\alpha_{g})\mathcal{N}(x|\boldsymbol{\mu}_{g},\eta_{g}\boldsymbol{\Sigma}_{g}) \right]
$$
There are cases where the assumption that the inflation factor is the same for all variables  measured in an observation within groups might be unrealistic. It is possible that the characteristics or variables being contaminated are a few instead of a all variables. To model this scenario the previous equation can be modified by replacing the scalar $\eta_{g}$ that is the inflation factor for all variables within group $g$ by a matrix $N_{g}$ which is a diagonal matrix where each element of the diagonal $\eta_{gj}$ for $j = 1,\dots,p$ represent the inflation factor for the corresponding variable.

$$
    f(\mathbf{x}|\vartheta) = \sum^{G}_{g=1} \pi_{g} \left[\alpha_{g} \mathcal{N}(x|\boldsymbol{\mu}_{g},\boldsymbol{\Sigma}_{g})  + (1-\alpha_{g})\mathcal{N}(x|\boldsymbol{\mu}_{g},\dot{N}_{g}\boldsymbol{\Sigma}_{g}\dot{N}^{T}_{g}) \right]
$$
$$
\dot{N}_{g} = \begin{bmatrix}
\sqrt{\eta_{g1}} &     0     & \dots     & 0         \\
0         & \sqrt{\eta_{g2}} & \dots     & 0         \\      
\dots     & \dots     & \dots     & \dots     \\
0         &     0     & \dots     & \sqrt{\eta_{gp}} \\   
\end{bmatrix}
$$


## Simulation study: Fitting a dataset that is designed to have different inflation factors within group

The covariance structure for this simulations is a diagonal matrix allowing elements of the diagonal taking different variances.    

$$
    \Sigma = 
\begin{bmatrix}
\sigma_{11} & 0 & 0 \\
0 & \sigma_{22} & 0 \\
0 & 0 & \sigma_{33} \\
\end{bmatrix}
$$


### Overview
In this section, the behavior of a contaminated mixture normal with different variables inflation factor within group is investigated. A simulated dataset of `r format(nobs_b,digits = 2)` observations in $p=$ `r format(p_b,digits = 2)` dimensions from one group was generated, from a  mixture of contaminated Gaussian distribution where `r percentage_trainning` of the samples composed the training subset and the remaining are part of the test subset. The parameters of the contaminated mixture normal are


$$
\mu = `r write_matex2(mu_b)` , \Sigma = `r write_matex2(sigma_b)`, \alpha = `r format(alpha_b,digits=2)`, \dot{N}_{g} = `r write_matex2(diag(sqrt(eta_b),p_b))`, {N}_{g} = `r write_matex2(diag(eta_b,p_b))`
$$
The main different between the second dataset versus the previous one is that the data is generated from allowing different variables inflation factor within the group. It is possible to see that $X_{2}$ has an inflation factor higher than $X_{1}$ and $X_{3}$. The experiment consist of fitting first the variable assuming the same variable inflation factor in the group and next allowing different variable inflation factor within the group and comparing the results obtained.

<p>
  <span style="color:blue;">&#9679;</span> True positive (true contaminated predicted as contaminated)
  <br>
  <span style="color:red;">&#9650;</span> True negative (true non-contaminated predicted as non-contaminated)
  <br>
  <span style="color:blue;">+</span> False positive (true non-contaminated predicted as contaminated)
  <br>
  <span style="color:red;">X</span> False negative (true contaminated predicted as non-contaminated)
</p>


```{r plotB_training, echo = FALSE}
pairs(DatasetB$Xtrain, panel = function(x,y, ...) {
  points(x,y, 
         col = ifelse(cond1BDif_testv == "11","blue",
                      ifelse(cond1BDif_testv == "00","red",
                        ifelse(cond1BDif_testv=="10","blue","red")) ),
          pch = ifelse(cond1BDif_testv == "11",19,
                      ifelse(cond1BDif_testv == "00",17,
                        ifelse(cond1BDif_testv=="10",3,4)) ),
         cex = 1,
         ...)
#           text(x[indBreal_T0_P1_Testv],y[indBreal_T0_P1_Testv],
#           labels=c(indBreal_T0_P1_Testv),pos = 4)
})
```
```{r plotB_test, echo= FALSE}
#pairs(DatasetB$Xtest, col = c("red","blue")[DatasetB$vtest + 1],
#      pch = ifelse(DatasetB$vtest == 0,24,19), cex = 1)
pairs(DatasetB$Xtest, panel = function(x,y, ...) {
  points(x,y, 
         col =  ifelse(cond1BDif_testv == "11","blue",
                      ifelse(cond1BDif_testv == "00","red",
                        ifelse(cond1BDif_testv=="10","blue","red")) ),
          pch = ifelse(cond1BDif_testv == "11",19,
                      ifelse(cond1BDif_testv == "00",17,
                        ifelse(cond1BDif_testv=="10",3,4)) ),
         cex = 1,
         ...)
#           text(x[indBreal_T0_P1_Testv],y[indBreal_T0_P1_Testv],
#           labels=c(indBreal_T0_P1_Testv),pos = 4)
})
```



### Using the real contamination information $\nu$'s to run a m-step for a model allowing different variable inflation factor within group to obtain parameter estimates for dataset B.

The parameter estimates for $\mu,\Sigma$ are quite close to the true parameter values. The model to be fitted has a diagonal covariance. There is a noticeable different in the estimate for $\alpha$ with respect to its true value. The estimation for $\alpha$ assumes that there are more contaminated samples than what the true parameter states. The estimation for $\eta$ for each variable is visible in the diagonal of the  matrix $N$. The model reaches convergence after `r format(fit_BDif$iterations,digits = 2)` steps and the parameter estimates are:

$$
\mu = `r write_matex2(mu_BrealDifr)` , \Sigma = `r write_matex2(sigma_BrealDifr)` , \alpha = `r alpha_BrealDifr`, \dot{N} * \dot{N}^{T} = N = `r write_matex2(eta_BrealDifr)`
$$


### Fitting a model with different variable inflation factor within group.

The parameters obtained for $\mu$, and $\Sigma$ are very similar to their true values. The main difference between the estimates produced by a model assuming equal variable inflation factors and different variable inflation factors lies in the estimates for $\alpha$. For the former model $\alpha$ is equal to `r format(ms_BDifrealv$alpha,digits = 2)` while the latter is equal to `r format(fit_BDif$alpha,digits = 2)` which means that it overestimated the percentage of non-contaminated samples. Also, the variable inflation factors estimates are different for all the variables as the elements of the diagonal of matrix $N$ shows. Moreover, the estimate for the variable inflation factor corresponding to $X_{2}$ is greater than its true value.



$$
\mu = `r write_matex2(mu_BDifr)` , \Sigma = `r write_matex2(sigma_BDifr)` , \alpha = `r alpha_BDifr`, \dot{N} * \dot{N}^{T} = N = `r write_matex2(eta_BDifr)`
$$
Taking a look of the performance of the model assuming same variable inflation factor within group we can see that it is able to identify `r format(100*Sensitivity_BDifTrain,digits=2)` and `r format(100*Sensitivity_BDifTest,digits=2)` contaminated samples in the training and test sets. 

<div style="display: flex; flex-direction: row; justify-content: space-between;">
```{r CM_B_Diftrain, echo = FALSE}
knitr::kable(table(Fact_BTrainv,Factpred_BDifTrainv), caption = "Different IF Train")
```
```{r CM_B_Diftest, echo = FALSE}
knitr::kable(table(Fact_BTestv,Factpred_BDifTestv), caption = "Different IF Test")
```
</div>


### Comparison between model that assume equal variable and different variable inflation factor within group for dataset B.

The rest of the metrics confirms that when the data was coming from different variables inflation factors the model allowing different inflation factor seems to be more appropriate than assuming equal inflation factor within group as long as the initial parameters values are close to the true values. 

<div style="display: flex; flex-direction: row; justify-content: space-between;">
```{r Df_CompBTrain, echo = FALSE}
#knitr::kable(df_B, format = "markdown")
knitr::kable(df_BDifTrain, caption = "Train")
```
```{r Df_CompBTest, echo = FALSE}
#knitr::kable(df_A, format = "markdown")
knitr::kable(df_BDifTest, caption = "Test")
```
</div>