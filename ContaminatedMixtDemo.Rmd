---
title: "Some of the functions in the ContaminatedMixt Package and the need of self-coded
  functions for m-step and e-step"
author: "Jorge Sanchez"
date: "2023-11-08"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Some interesting functions in the ContamiantedMixt package to work with contaminated mixtures of normal distributions

There are some functions relevant to work with contaminated mixture of normal distributions such as **m.step**, **CNmixt**, and **CNpredict**. 
The m.step function receive as input the observations that conforms the training set, the model to be fitted, the group information, and lastly the number maximum of iterations to convert. The output of this function returns the estimates for $\{\mu_{g}, \Sigma_{g}, \Sigma^{-1}_{g}, \pi_{g}\}^{G}_{g=1}$ the mean,variance matrix, inverse variance-covariance matrix, and the posterior distribution for each group. However, this function does not return estimates for parameters $\{\alpha_{g},\eta_{g}\}^{G}_{g=1}$ the percentage of non-contaminated observations and inflation factor for each group. The absence of estimates for these parameters that would be required for an e-step makes sensible an implementation of an m-step that returns these estimates.

### Using **m.step** function to obtain parameter estimates

A contaminated normal distribution is simulated with parameters $\mu_{1} = (0,0,0,0,0), \mu_{2} = c(0,6,0,6,0), \Sigma_{1} = \Sigma_{2} = Diag(1,1,1,1,1), \alpha_{1} = \alpha_{2} = 0.8, \eta_{1} = \eta_{2} = 20$. The estimates obtained using **m.step** function for $\mu_{1},mu_{2},\Sigma_{1},\Sigma_{2}$ are shown below:

```{r load_data, echo = FALSE, message = FALSE, warning = FALSE}
library(ContaminatedMixt)
source("CMNFunctionsV2.R")

pathWd <-"/home/jsancheg/git_environment/LDA_CMN/"
setwd(pathWd)

system_info <- Sys.info()
#OS_name <- system_info("")
pc_name <- system_info['nodename'] 

# dir(pathWd)

if(pc_name == "LAPTOP-ADR3M911")
{
  pathScenarios <- "E:/University of Glasgow/Thesis/Scenarios/"
  pathScenarios1 <- "E:/University of Glasgow/Thesis/Scenarios1/"
  
  pathSSFiles <- "E:/University of Glasgow/Thesis/SSFiles/"
  pathSSFiles1 <- "E:/University of Glasgow/Thesis/SSFiles1/"
  
  pathSFiles <- "E:/University of Glasgow/Thesis/SFiles/"
  
}else if(pc_name == "WildFree")
{
  pathScenarios <- "/home/jsancheg/Documents/Scenarios/"
  pathSSFiles <- "/home/jsancheg/Documents/SSFiles/"
  pathSFiles <- "/home/jsancheg/Documents/SFiles/"
  
} else
{
  pathScenarios <- "M:/Scenarios/"
  pathSSFiles <- "M:/SSFiles/"
  pathSFiles <- "M:/SFiles/"
}


pathOutput <- "/home/jsancheg/git_environment/LDA_CMN/Scenarios/"

# dir(pathOutput)

fileRDS<- readRDS(paste0(pathScenarios,"S_2_2_5_4000_85_INB_SCBSV_VO_A9080_E3020_10.RDS"))
GenData <-fileRDS$GenData[[1]]
par <- fileRDS$par

G = length(unique(GenData$l))
Xtrain <- GenData$Xtrain
Xtest <- GenData$Xtest
ltrain <- GenData$ltrain
ltest <- GenData$ltest
vtest <- GenData$vtest
```

```{r mstep}
# ContaminatedMixt::m step
estimates <- ContaminatedMixt::m.step(Xtrain,modelname = "VVV",z = unmap(ltrain), mmax = 10)
estimates$mu
estimates$Sigma
```

### Using **CNmixt** function to obtain parameter estimates

It is possible to obtain parameter estimates using **CNmixt** function for the same contaminated data set. The main difference between **m.step** and **CNmixt** is that the later return estimates for the percengate of non-contaminated samples and inflation factor in each group. The results are as follows:
```{r Cnmixt}
# predict using the function fitCMN from ContaminatedMixt packages
# supervised version

fitCMN <- CNmixt(Xtrain,G,contamination = TRUE,model = "VVV", 
                 initialization = "mixt",label = ltrain, 
                 iter.max = 10)

Models <- c("EEI","VVI","VVV")
fitCMN1 <- CNmixt(Xtrain,G,model = Models, 
                 initialization = "mixt",label = ltrain, 
                 iter.max = 10)
length(fitCMN1$models)

cbind(fitCMN1$models[[1]]$model,fitCMN1$models[[1]]$contamination)
cbind(fitCMN1$models[[2]]$model,fitCMN1$models[[2]]$contamination)
cbind(fitCMN1$models[[3]]$model,fitCMN1$models[[3]]$contamination)
cbind(fitCMN1$models[[4]]$model,fitCMN1$models[[4]]$contamination)
cbind(fitCMN1$models[[5]]$model,fitCMN1$models[[5]]$contamination)
cbind(fitCMN1$models[[6]]$model,fitCMN1$models[[6]]$contamination)

fitCMN10 <- CNmixt(Xtrain,G,model = "VVV", 
                 initialization = "mixt",label = ltrain, 
                 iter.max = 10)
length(fitCMN10$models)
cbind(fitCMN10$models[[1]]$model,fitCMN10$models[[1]]$contamination)
cbind(fitCMN10$models[[2]]$model,fitCMN10$models[[2]]$contamination)


fitCMN20 <- ContaminatedMixt::getBestModel(fitCMN1,criterion ="BIC", contamination = FALSE)
fitCMN30 <- ContaminatedMixt::getBestModel(fitCMN1,criterion ="BIC", contamination = TRUE)

cbind(fitCMN20$models[[1]]$model,fitCMN20$models[[1]]$contamination)
length(fitCMN20$models)


fitCMN$models[[1]]$mu
fitCMN$models[[1]]$Sigma
fitCMN$models[[1]]$alpha
fitCMN$models[[1]]$eta


```

### Using self-coded function to obtain parameter estimates

```{r self-coded}
fitCMN_SelfCoded <- ModelAccuracy2(Xtrain,Xtest,ltrain,ltest,"VVV",niterations = 10)

fitCMN_SelfCoded$mu[[10]]
fitCMN_SelfCoded$sigma[[10]]
fitCMN_SelfCoded$alpha[[10]]
fitCMN_SelfCoded$eta[[10]]
```

### Using **CNpredict** function to obtain predictions 
This function has a limitation that when the parameters $\alpha$ and $\eta$ are passed, it returns an error. However, it works well when these parameters are set NULL values.


```{r CNpredictContaminatedParametersNULL}

predCMN <- CNpredict(newdata = Xtest, 
                     prior = fitCMN$models[[1]]$prior,
                     mu = fitCMN$models[[1]]$mu,
                     invSigma = fitCMN$models[[1]]$invSigma,
                     alpha = NULL,
                     eta = NULL)
predCMN
```

Hence a E-step function is needed in order to predict contaminated observations.

